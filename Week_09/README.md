### 第 19 课
+ 动态规划、状态转移方程串讲
    + 递归、分治、回溯(回溯就是递归和分治加了一段清除当前层状态的逻辑)
        + 数学归纳法的思维
        + 要用机器的思维,不要想着把每一层都掌控住,只写好当前层,然后其它层都调用当前层的逻辑就好
        + 摒弃人脑的思维
    + 动态规划
        + 其实就是 分治+记忆化
        + 动态规划的要点
            + 将复杂的问题分解为各个简单的子问题
            + 分治+最优子结构
            + 顺推形式: 动态递推(从下往上推)
            + 动态规划 DP 顺推模板
            + 
```
public void DP() {
    int[][] dp = new int[m][n]; // 二维情况
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            dp[i][j] = funnction(dp[i'][j'] ... );
        }
    }
    return dp[m][n];
}
```

   + 关键点
        + 动态规划和递归或者分治没有根本上的区别 (关键看有无最优子结构)
        + 共性: 找到重复子问题
        + 差异性: 动态规划处理最优子结构、中途可以淘汰次优解
   + 动态规划三部曲
        + 定义状态 
        + 套用模板
        + 写出循环
   + 高级动态规划题目详解
        + 复杂度来源
        + 状态用哪个有更多维度 (二维、三维、或者更多甚至需要压缩)
        + 状态方程更加复杂
   + 本质: 内功、逻辑思维、数学


### 第 20 课
+ 字符串基础知识和引申题目
    + 高级字符串算法
        + 最长子序列
https://leetcode-cn.com/problems/longest-common-subsequence/
        + dp[i][j] = dp[i-1][j-1] + 1 (if s1[i-1] == s2[j-1])
        + else dp[i][j] = max(dp[i-1][j],dp[i][j-1])


   + 最长公共子串
        + dp[i][j] = dp[i-1][j-1] + 1 (if s1[i-1] == s2[j-1])
        + else dp[i][j] = 0


    + 不同的子序列
        + https://leetcode-cn.com/problems/distinct-subsequences/

        + dp[i][j] 代表 T 前 i 字符串可以由 S 前 j 字符串组成最多个数
        + S[j] == T[i],dp[i][j] = dp[i-1][j-1] +  dp[i][j-1]
        + S[j] != T[i],dp[i][j] = dp[i][j-1]