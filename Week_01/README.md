学习笔记

## 第三课
 + 跳表的插入，删除，查询的复杂度都为 O(logn)，用了升维的思想。因为数组和链表都是一维的数据结构，其携带的信息是有限的。如果想要提升复杂度就要想办法使其携带更多的信息，可以通过升维解决
 + 移动 0 
    + 解法：https://leetcode-cn.com/problems/move-zeroes/submissions/
    + 官方解不一定是最优的，要多看看国际站中的题解
 + 乘最多水的容器
   + 解法：https://leetcode-cn.com/problems/container-with-most-water/submissions/
   + 解这类数组类的题，很多用到的方法就是一维数组的坐标变换，一位数组坐标变换中有一个思想是左右边界向内收敛，又叫左右夹逼，是解决这类问题较为通用的思路
   + 左右挪动边界的时候用了一个 i++，应该注意 i++和++i 的区别 
 + 爬楼梯问题
   + 解法：https://leetcode-cn.com/problems/climbing-stairs/submissions/
   + 最大的误区：做题只做一遍
   + 优化的思想：空间换时间 和 升维
   + 所有的问题到最后应该是找重复性的问题，应为计算机就是做的重复的事情
   + 解题思路
      + 爬楼梯问题，比较抽象，不知道从哪里下手
      + 开始尝试列举，观察规律
          // 1：1
          // 2：2
          // 3：f(1) + f(2)
          // 4: f(2) + f(3)
          // n: f(n-1) + f(n-2)  斐波拉契数列
      + 第一个台阶只有一种；第二个台阶有两种；第三个台阶，要么从第一个台阶上来，要么从第二个台阶上来；第 n 个台阶，要么从第n-1 个上来，要么从第 n-2 个上来（因为每次只能迈一步或两步），到最后转换成了斐波那契数列
      + 可以使用递归，但时间复杂度太大 O(2^n)
      + 然后想办法优化，空间换时间，用一个数组存储已经计算过的数据
      + 也可以不用开辟新数组的方法，直接用两个 int 来记录上两次的结果，可以达到空间复杂度为 O(1)

## 第四课
 + Queue的源码分析
    + Queue是一个接口，继承了Collection接口。Queue接口只包含抽象方法。
    + add(E e)：往队列尾部添加元素，如果添加成功则返回true，如果因为容量限制导致添加失败则抛出IllegalStateException异常。
    + offer(E e) : 往队列尾部添加元素，如果添加成功则返回true，如果因为容量限制导致添加失败则返回false。可见在有容量限制的队列中，offer方法由于add方法。
    + remove() : 删除队列头部的元素并返回，如果队列为空则抛出NoSuchElementException。
    + poll() : 删除队列头部的元素并返回，如果队列为空则返回null。
    + element() : 返回队列头部的元素（不从队列删除元素），如果队列为空则抛出NoSuchElementException。
    + peek() : 返回队列头部的元素（不从队列删除元素），如果队列为空则返回null。
 + PriorityQueue的源码分析
    + PriorityQueue是一个具体类，其底层实现为数组。
    + offer(E e)，添加元素，当参数e为空时抛出NullPointerException异常，否则执行添加元素，首先判断是否需要扩容，以及在需要扩容的情况下进行扩容，然后将e加到数组末尾，最后对e进行上浮操作以保持优先队列的性质（例如当头部元素最小时，每个元素都比其子节点小）。
    + add(E e)，其方法内部使用 offer 方法实现。
    + peek()，查看头部元素，如果优先队列为空则返回null，否则返回数组的第一个元素。
    + poll()，移除头部元素并返回，如果优先队列为空则返回null，否则将数组的第一个元素作为返回值，将数组的最后一个元素移到数组的第一个元素（原来的最后一个元素变成null），对数组的第一个元素进行下沉操作以保持优先队列的性质（例如当头部元素最小时，每个元素都比其子节点小），最后返回移除的元素。
