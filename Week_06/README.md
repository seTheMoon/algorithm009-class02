学习笔记
### 第 12 课
+ 动态规划
   + 动态规划和递归或者分治没有根本上的区别(关键看有无最优的子结构)
   + 如果没有最优子结构,说明所有的子问题都需要计算一遍,同时把最后的结果合并在一起,此时就是分治
   + 共性:找到重复子问题
   + 差异性:最优子结构、中途可以淘汰次优解
   + (回溯就是穷举,剪枝就是去掉不可能的分支)
   + 动态规划关键点
      + 最优子结构 opt[n] = best_of(opt[n-1],opt[n-2],...)
      + 储存中间状态:opt[i]
      + 递推公式(美其名曰:状态转移方程或者 DP 方程)
   + Fib:opt[i] = opt[n-2] + opt[n-2]
   + 二维路径 : opt[i][j] = opt[i+1][j] + opt[i][j+1](且判断a[i,j]是否空地)
   + 动态规划小结
      + 打破自己的思维惯性,形成机器思维
      + 理解复杂逻辑 的关键
      + 也是职业进阶的要点要领
   + MIT 的 5 步解 dp
    + 分治,把当前的复杂问题转换成一个简单的子问题
      + 猜递推方程
      + 合并子问题的解
      + 递归和记忆化
      + 解决问题
 + 最大子序和
   + 题解:https://leetcode-cn.com/problems/maximum-subarray/
   + 思路
   + 使用动态规划,先回忆动态规划的步骤
      + 分治    max_sum(i) = Max(max_sum(i-1),0) + i
      + 状态数组定义    f[i]
      + DP 方程    f[i] = Max(f[i-1],0) + a[i]
