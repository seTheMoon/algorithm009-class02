学习笔记
### 第 5 课
+ 有效的字母异位词
   + 解法：https://leetcode-cn.com/problems/valid-anagram/submissions/
   + 思路
      + 第一次是用了两个 map，分别将两个字符数组的字符及个数放入其中，最后再遍历一遍对比，这种方法比较普通，且开了两个 map
      + 第二次只开辟了一个新数组，利用 hashmap 的思想，开辟了一个大小为 26 的数组，以字符在字母表中的位置为 index存入相应的数组中，遍历字符串，第一个字符加一，第二个字符减一，最后遍历一遍看是否有不为 0 的值。
      + 第二种方法，主要是效仿了 hashmap 的思想，天然的利用字母在字母表中的位置作为数组中的 index，使一维数组携带了更多的信息，思路非常巧妙
+ 字母异位次分组
    + 解法：https://leetcode-cn.com/problems/group-anagrams/submissions/
    + 思路
        + 第一次的解法中规中矩
        + 第二次的解法思路比较巧妙，使用开辟大小为 26 的新数组+字符在字母表中的位置作为 index 的方式替代对数组进行排序，使时间复杂度由 O(NK * logK) 降低到 O(NK)

### 第六课
+ 树与图
    + 没有环的是树，有环的是图
    + 二叉树是只有两个子节点的树
    + 链表是特殊的树，树是特殊的图
    + 树的遍历分前序，中序，后序，前中后的顺序就是根据遍历时查看根节点的顺序
    + 前序遍历：根节点-左子节点-右子节点
    + 中序遍历：左子节点-根节点-右子节点
    + 后序遍历：左子节点-右子节点-根节点
    + 为什么要有二叉搜索树？因为一个普通的树，要查找某一个节点，他的时间复杂度为 O(n),和链表一样，这样没有意义
+ 二叉搜索树
    + 也称二叉排序树，有序二叉树，排序二叉树，是指一颗空树或者具有以下性质的二叉树
        + 左子树上所有节点的值均小于他的根节点的值
        + 又子树上所有节点的值均大于他的根节点的值
        + 左右子树也分别为二叉搜索树（重复性！！！）
    + 中序遍历是升序遍历
    + 二叉搜索树的查询，插入，删除时间复杂度都是 O(logN)
+ 堆 heap
    + 可以迅速在一堆数中找到最大或最小值的数据结构
    + 将根节点最大的堆叫做大顶堆或大根堆，将根节点最小的堆叫做小顶堆或小根堆
    + 常见的堆有二叉堆，斐波拉契堆。
    + 注意：要么就是找最大值，要么就是找最小值，不能两者兼并
    + 堆是一个抽象的数据结构，是表示可以迅速在一堆数中找到最大或最小值的一种数据结构
+ 二叉堆
    + 通过完全二叉树来实现
    + 二叉堆（大顶）具有以下性质：
        + 是一颗完全二叉树
        + 树中任意节点的值总是 >= 其子节点的值(子节点即紧挨着的左节点和右节点)（这个性质可以保证根节点总是最大的节点）
    + 二叉堆一般是通过数组实现的，根节点的索引为 0 时：
        + 索引为 i 的父节点的左子节点索引为：2 * i + 1
        + 索引为 i 的父节点的右子节点索引为：2 * i + 2
        + 索引为 i 的子节点的父节点索引为：(i - 1) / 2 取整
    + 二叉堆的插入操作
        + 新元素一律先插入到堆的尾部
        + 依次从尾部向上调整整个堆结构（一直到根即可）heapifyUp(一次一次的和父节点对比，向上浮动)
    + 二叉堆的删除操作
        + 将堆尾元素替换到顶部
        + 依次从根部向下调整整个堆结构 heapifyDown(一次一次的和子节点较大的换位)
    + 二叉堆是堆（优先队列 priorityQueue）的一种常见且简单的实现，它并不是最优的实现
    + java 中 PriorityQueue 是使用二叉堆来实现的，默认是大顶堆，可以通过传入 Compaire 来定义
    ```
    // 大顶堆
    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> (o2 - o1));
    // 小顶堆
    PriorityQueue<Integer> queue = new PriorityQueue<>((o1,o2) -> (o2 - o2));
    ```
+ 前 k 个高频元素
    + 解法：https://leetcode-cn.com/problems/top-k-frequent-elements/
    + 其实解法不难，重点是应该想到，遇见 topK 这种类似的问题就应该用堆来解决
    在往下一步，是不是凡是最值的问题都可以使用堆解决？
+ 丑数
    + 解法：https://leetcode-cn.com/problems/chou-shu-lcof/
    + 由于丑数是只包含因子 2，3，5 的数，则2，3，5 相互乘积就是丑数。可以利用小顶堆，堆顶元素出堆，一次乘以 2，3，5，积再入堆，依次循环。由于利用了堆的小顶堆的性质，每次出堆的都是当前堆中最小的，因此可以保证 2，3，5，4，6。。。的顺序

### HashMap 总结
+ 初始化
    + 首先默认大小是 16
    + 首先负载因子默认是 0.75，即集合中的元素个数到达 0.75 倍是就要扩容
+ put 操作
    + HashMap 的底层使用数组+双项链表+红黑树实现的
    + 如果是第一次执行put 操作，则初始化底层的数组，大小为 16
    + 然后判断 key 是否存在
        + 对 key 进行 hash 操作，并使用(n-1)&hash的与操作得到这个 key 应该在数组中的位置
            + 之所以要使用与操作，是因为与操作比取模运算更快
            + 之所以数组 resize 时都是乘 2，一是是为了要保证 (n-1)&hash=hash%size
        + 如果 key 不存在，就直接在这个位置添加节点
        + 如果 key 的 hash 值重复
            + 如果当亲节点是红黑树，则直接放进去
            + 如果当前节点是链表，则加在后面
            + 如果当前节点是链表，加在后面之后大小等于 8 了，则将链表转为红黑树